#ifndef ANGELSCRIPT_CASBASECLASS_H
#define ANGELSCRIPT_CASBASECLASS_H

/**
*	Base class for all Angelscript classes that require memory leak tracking
*/
class CASBaseClass
{
public:
	CASBaseClass();

	//Copy constructor and assignment operator are autogenerated
	~CASBaseClass();
};

/**
*	Base class for all Angelscript classes that are reference counted
*/
class CASRefCountedBaseClass : public CASBaseClass
{
public:
	CASRefCountedBaseClass()
		: m_iRefCount( 1 )
	{
	}

	CASRefCountedBaseClass( const CASRefCountedBaseClass& )
		: m_iRefCount( 1 )
	{
	}

	//Assignment operator is autogenerated
	~CASRefCountedBaseClass() {}

	int GetRefCount() const { return m_iRefCount; }

	void AddRef() const;

protected:
	//Returns true if the reference count has become 0
	bool InternalRelease() const;

protected:
	mutable int m_iRefCount;
};

/**
*	Base class for all Angelscript classes that are reference counted and are used acrosss threads
*/
class CASAtomicRefCountedBaseClass : public CASRefCountedBaseClass
{
public:
	CASAtomicRefCountedBaseClass() {}
	~CASAtomicRefCountedBaseClass() {}

	//Copy constructor and assignment operator are autogenerated

	void AddRef() const;

protected:
	//Returns true if the reference count has become 0
	bool InternalRelease() const;
};

/**
*	Garbage collected base class
*	Pass in either CASRefCountedBaseClass or CASAtomicRefCountedBaseClass as the base class
*/
template<typename BASECLASS>
class CASGCBaseClass : public BASECLASS
{
public:
	CASGCBaseClass()
		: m_fGCFlag( false )
	{
	}

	bool GetGCFlag() const { return m_fGCFlag; }
	void SetGCFlag() const { m_fGCFlag = true; }

	void AddRef() const
	{
		m_fGCFlag = false;

		BASECLASS::AddRef();
	}

protected:

	bool InternalRelease() const
	{
		m_fGCFlag = false;

		return BASECLASS::InternalRelease();
	}

private:
	mutable bool m_fGCFlag;
};

typedef CASGCBaseClass<CASRefCountedBaseClass> CASGCRefCountedBaseClass;
typedef CASGCBaseClass<CASAtomicRefCountedBaseClass> CASGCAtomicRefCountedBaseClass;

#endif //ANGELSCRIPT_CASBASECLASS_H
